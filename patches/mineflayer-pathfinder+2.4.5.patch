diff --git a/node_modules/mineflayer-pathfinder/index.js b/node_modules/mineflayer-pathfinder/index.js
index b38bd30..750af7e 100644
--- a/node_modules/mineflayer-pathfinder/index.js
+++ b/node_modules/mineflayer-pathfinder/index.js
@@ -439,13 +439,32 @@ function inject (bot) {
       }
     }
 
+    // [mindaxis-patch:water-astar-skip-v2] [mindaxis-patch:water-astar-skip] liquidCost=0: 水中でも A* 継続
+    // [mindaxis-patch:astar-bg-timeout-v2] A* バックグラウンド計算の全環境タイムアウト（15秒）+ stop
     if (astarContext && astartTimedout) {
-      const results = astarContext.compute()
-      results.path = postProcessPath(results.path)
-      pathFromPlayer(results.path)
-      bot.emit('path_update', results)
-      path = results.path
-      astartTimedout = results.status === 'partial'
+      if (!bot._astarBgStart) bot._astarBgStart = Date.now()
+      if (Date.now() - bot._astarBgStart > 15000) {
+        if (!bot._astarConsecutiveTimeouts) bot._astarConsecutiveTimeouts = 0
+        bot._astarConsecutiveTimeouts++
+        console.log('[mindaxis] A* background computation timed out (15s), stopping pathfinder (consecutive=' + bot._astarConsecutiveTimeouts + ')')
+        astartTimedout = false
+        astarContext = null
+        bot._astarBgStart = 0
+        bot.pathfinder.stop()
+        if (bot._astarConsecutiveTimeouts >= 5) {
+          console.log('[mindaxis] A* 5 consecutive timeouts, forcing interrupt_code')
+          bot.interrupt_code = true
+          bot._astarConsecutiveTimeouts = 0
+        }
+      } else {
+        const results = astarContext.compute()
+        results.path = postProcessPath(results.path)
+        pathFromPlayer(results.path)
+        bot.emit('path_update', results)
+        path = results.path
+        astartTimedout = results.status === 'partial'
+        if (!astartTimedout) { bot._astarBgStart = 0; bot._astarConsecutiveTimeouts = 0; }
+      }
     }
 
     if (bot.pathfinder.LOSWhenPlacingBlocks && returningPos) {
@@ -463,16 +482,46 @@ function inject (bot) {
             fullStop()
           }
         } else if (!pathUpdated) {
+          // [mindaxis-patch:water-skip-repath-v2] [mindaxis-patch:water-skip-repath] 水中でも A* パス計算を常に実行
+          // [mindaxis-patch:repath-timeout-v2] repath に 0.5s タイムアウト: event loop 詰まりで MC keepalive 切断を防ぐ
           const results = bot.pathfinder.getPathTo(stateMovements, stateGoal, 500)
           bot.emit('path_update', results)
           path = results.path
           astartTimedout = results.status === 'partial'
           pathUpdated = true
         }
       }
     }
 
     if (path.length === 0) {
+      // [mindaxis-patch:water-direct] 水中でゴールに直接泳ぐ（A* 再計算をバイパス）
+      const _wdFeet = bot.blockAt(bot.entity.position.floored())
+      const _wdBelow = bot.blockAt(bot.entity.position.floored().offset(0, -1, 0))
+      const _wdBelow2 = bot.blockAt(bot.entity.position.floored().offset(0, -2, 0))
+      const _wdInWater = bot.entity.isInWater || (_wdFeet && _wdFeet.type === waterType) || (_wdBelow && _wdBelow.type === waterType) || (_wdBelow2 && _wdBelow2.type === waterType)
+      if (_wdInWater && stateGoal && stateGoal.x != null && stateGoal.z != null) {
+        // [mindaxis-patch:water-stop] stopPathing チェック（stop() が効くようにする）
+        if (stopPathing) { stop(); return }
+        // ゴール到達チェック
+        if (stateGoal.isEnd(bot.entity.position.floored()) || stateGoal.isEnd(bot.entity.position.floored().offset(0, 1, 0))) {
+          if (!dynamicGoal) {
+            bot.emit('goal_reached', stateGoal)
+            stateGoal = null
+            fullStop()
+          }
+          return
+        }
+        // ゴールに向かって直接泳ぐ（yaw デッドゾーンでキョロキョロ防止）
+        const _gdx = stateGoal.x - bot.entity.position.x
+        const _gdz = stateGoal.z - bot.entity.position.z
+        const _targetYaw = Math.atan2(-_gdx, -_gdz)
+        const _yawDiff = ((_targetYaw - bot.entity.yaw + Math.PI * 3) % (Math.PI * 2)) - Math.PI
+        if (Math.abs(_yawDiff) > 0.15) bot.look(_targetYaw, 0)
+        bot.setControlState('forward', true)
+        bot.setControlState('jump', true)
+        if (stateMovements && stateMovements.allowSprinting) bot.setControlState('sprint', true)
+        return
+      }
       return
     }
 
@@ -590,8 +639,13 @@ function inject (bot) {
         if (!dynamicGoal && stateGoal && (stateGoal.isEnd(p.floored()) || stateGoal.isEnd(p.floored().offset(0, 1, 0)))) {
           bot.emit('goal_reached', stateGoal)
           stateGoal = null
+          fullStop()
+        } else if (stateGoal) {
+          // [mindaxis-patch:water-recompute-v2] [mindaxis-patch:water-recompute] 水中でも A* 再計算を許可
+          pathUpdated = false
+        } else {
+          fullStop()
         }
-        fullStop()
         return
       }
       // not done yet
@@ -608,7 +662,22 @@ function inject (bot) {
     bot.setControlState('forward', true)
     bot.setControlState('jump', false)
 
-    if (bot.entity.isInWater) {
+    // [mindaxis-patch:water-surface] 水中移動の根本修正
+    // 水面ボビング対策: 2ブロック下まで水を検出（jump で水面から飛び出した時も _nearWater=true を維持）
+    // _nearWater=true なら水泳制御、false なら陸上の物理チェーンに委譲
+    const _feetBlock = bot.blockAt(bot.entity.position.floored())
+    const _belowBlock = bot.blockAt(bot.entity.position.floored().offset(0, -1, 0))
+    const _below2Block = bot.blockAt(bot.entity.position.floored().offset(0, -2, 0))
+    const _nearWater = bot.entity.isInWater || (_feetBlock && _feetBlock.type === waterType) || (_belowBlock && _belowBlock.type === waterType) || (_below2Block && _below2Block.type === waterType)
+    if (_nearWater) {
+      const _needSwimUp = path.length > 0 && path[0].y > bot.entity.position.y + 0.5
+      // [mindaxis-patch:water-no-jump-down] 次ステップが下方向（陸に降りる）なら jump しない（y=67 オーバーシュート防止）
+      const _nextStepDown = path.length > 0 && path[0].y < bot.entity.position.y - 0.3
+      if ((!bot.entity.onGround || _needSwimUp) && !_nextStepDown) {
+        bot.setControlState('jump', true)
+      }
+      if (stateMovements.allowSprinting) {
+        bot.setControlState('sprint', true)
+      }
+    } else if (bot.entity.isInLava) {
       bot.setControlState('jump', true)
       bot.setControlState('sprint', false)
     } else if (stateMovements.allowSprinting && physics.canStraightLine(path, true)) {
@@ -629,8 +698,13 @@ function inject (bot) {
     }
 
     // check for futility
-    if (performance.now() - lastNodeTime > 3500) {
-      // should never take this long to go to the next node
+    // [mindaxis-patch:water-stuck-timeout] 水中はタイムアウトを延長
+    const _feetB = bot.blockAt(bot.entity.position.floored())
+    const _belowB = bot.blockAt(bot.entity.position.floored().offset(0, -1, 0))
+    const _below2B = bot.blockAt(bot.entity.position.floored().offset(0, -2, 0))
+    const _inWaterArea = bot.entity.isInWater || bot.entity.isInLava || (_feetB && _feetB.type === waterType) || (_belowB && _belowB.type === waterType) || (_below2B && _below2B.type === waterType)
+    const _stuckMs = _inWaterArea ? 10000 : 3500;
+    if (performance.now() - lastNodeTime > _stuckMs) {
       resetPath('stuck')
     }
   }
diff --git a/node_modules/mineflayer-pathfinder/lib/movements.js b/node_modules/mineflayer-pathfinder/lib/movements.js
index a7e3505..6f9ae22 100644
--- a/node_modules/mineflayer-pathfinder/lib/movements.js
+++ b/node_modules/mineflayer-pathfinder/lib/movements.js
@@ -55,6 +55,10 @@ class Movements {
     this.liquids = new Set()
     this.liquids.add(registry.blocksByName.water.id)
     this.liquids.add(registry.blocksByName.lava.id)
+    // [mindaxis-patch:water-flowing-liquids] flowing_water/flowing_lava を液体として認識
+    if (registry.blocksByName.flowing_water) this.liquids.add(registry.blocksByName.flowing_water.id)
+    if (registry.blocksByName.flowing_lava) this.liquids.add(registry.blocksByName.flowing_lava.id)
+    this.flowingWaterType = registry.blocksByName.flowing_water ? registry.blocksByName.flowing_water.id : -1
 
     this.gravityBlocks = new Set()
     this.gravityBlocks.add(registry.blocksByName.sand.id)
@@ -396,6 +400,8 @@ class Movements {
     }
 
     if (this.getBlock(node, 0, 0, 0).liquid) cost += this.liquidCost
+    // [mindaxis-patch:water-flowing-cost] 水流ブロックへの移動は追加コスト
+    if (blockC.type === this.flowingWaterType) cost += 3
 
     neighbors.push(new Move(blockC.position.x, blockC.position.y, blockC.position.z, node.remainingBlocks - toPlace.length, cost, toBreak, toPlace))
   }
@@ -493,7 +499,8 @@ class Movements {
     cost += this.safeOrBreak(blockD, toBreak)
     if (cost > 100) return
 
-    if (blockC.liquid) return // dont go underwater
+    // [mindaxis-patch:water-dropdown-v2] [mindaxis-patch:water-dropdown] 水底ダイブ防止: 降下は中コスト
+    if (blockC.liquid) cost += 5
 
     cost += this.getNumEntitiesAt(blockLand.position, 0, 0, 0) * this.entityCost // add cost for entities
 
@@ -513,7 +520,8 @@ class Movements {
     cost += this.safeOrBreak(block0, toBreak)
     if (cost > 100) return
 
-    if (this.getBlock(node, 0, 0, 0).liquid) return // dont go underwater
+    // [mindaxis-patch:water-down-v2] [mindaxis-patch:water-down] 水底ダイブ防止: 下方向は高コスト
+    if (this.getBlock(node, 0, 0, 0).liquid) cost += 10
 
     cost += this.getNumEntitiesAt(blockLand.position, 0, 0, 0) * this.entityCost // add cost for entities
 
@@ -522,18 +530,19 @@ class Movements {
 
   getMoveUp (node, neighbors) {
     const block1 = this.getBlock(node, 0, 0, 0)
-    if (block1.liquid) return
+    // [mindaxis-patch:water-up] 水中の上方向移動を許可（早期 return せずコスト加算）
     if (this.getNumEntitiesAt(node, 0, 0, 0) > 0) return // an entity (besides the player) is blocking the building area
 
     const block2 = this.getBlock(node, 0, 2, 0)
 
     let cost = 1 // move cost
+    if (block1.liquid) cost += this.liquidCost // [mindaxis-patch:water-up]
     const toBreak = []
     const toPlace = []
     cost += this.safeOrBreak(block2, toBreak)
     if (cost > 100) return
 
-    if (!block1.climbable) {
+    if (!block1.climbable && !block1.liquid) { // [mindaxis-patch:water-up]
       if (!this.allow1by1towers || node.remainingBlocks === 0) return // not enough blocks to place
 
       if (!block1.replaceable) {
@@ -561,9 +570,9 @@ class Movements {
     if ((block1.physical && block1.height >= block0.height) ||
       !this.getBlock(node, dir.x, 0, dir.z).safe ||
       !this.getBlock(node, dir.x, 1, dir.z).safe) return
-    if (this.getBlock(node, 0, 0, 0).liquid) return // cant jump from water
-
+    // [mindaxis-patch:water-parkour] 水中からのパーカーを許可（liquidCost 加算）
     let cost = 1
+    if (this.getBlock(node, 0, 0, 0).liquid) cost += this.liquidCost
 
     // Leaving entities at the ceiling level (along path) out for now because there are few cases where that will be important
     cost += this.getNumEntitiesAt(node, dir.x, 0, dir.z) * this.entityCost
